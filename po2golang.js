/* eslint-disable require-jsdoc */
import fs from 'node:fs';
import path from 'node:path';
import {po} from 'gettext-parser';

const autogenMsg = `// AUTOGENERATED FILE: DO NOT MODIFY BY HAND.
// Instead, modify the .po files in
// https://github.com/hebcal/hebcal-locales.git
// and run
//
//\tnpm run po2golang
//
// there. Then copy the contents of the go/ folder.`;

const langs = new Set();
const parsedPoData = new Map();
for (const arg of process.argv.slice(2)) {
  const contents = fs.readFileSync(arg);
  const input = contents.toString().normalize();
  const poData = po.parse(input);
  const langName = getLangFromBase(arg);
  const arr = parsedPoData.get(langName);
  if (arr) {
    arr.push(poData);
  } else {
    parsedPoData.set(langName, [poData]);
  }
  langs.add(langName);
}

const dir = './go';
if (!fs.existsSync(dir)) {
  try {
    fs.mkdirSync(dir);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
}

for (const langName of langs.values()) {
  const baseName = langName.replaceAll('-', '_');
  const outpath = `${dir}/strings_${baseName}.go`;
  console.log(`${langName} => ${outpath}`);
  writePoFile(parsedPoData.get(langName), outpath, langName);
  langs.add(langName);
}

const outstream = fs.createWriteStream(`${dir}/locales.go`, {flags: 'w'});
outstream.write(`package locales

${autogenMsg}

import "strings"

// AllLocales is an array of all supported locale names.
var AllLocales = []string{
\t"en",
`);
for (const langName of langs.values()) {
  outstream.write(`\t"${langName}",\n`);
}
outstream.write(`}

// LookupTranslation returns a message for the given key.
// It returns false for ok if such a message could not be found.
func LookupTranslation(key string, locale string) (string, bool) {
\tlang := strings.ToLower(locale)
\tswitch lang {
\tcase "", "en", "sephardic":
\t\treturn key, true
\tcase "he-x-nonikud":
\t\tv, ok := Lookup_he_x_NoNikud(key)
\t\tif ok {
\t\t\treturn v, true
\t\t}
\t\tv, ok = Lookup_he(key)
\t\tif ok {
\t\t\treturn HebrewStripNikkud(v), true
\t\t}
\t\treturn v, ok
`);
for (const langName of langs.values()) {
  if (langName !== 'he-x-NoNikud') {
    outstream.write(`\tcase "${langName}":\n`);
    outstream.write(`\t\treturn Lookup_${langName}(key)\n`);
  }
}

outstream.write(`\t}\n\treturn key, false\n}\n`);
outstream.end();

function getLangFromBase(arg) {
  return path.basename(arg).replace(/\.po$/, '').replace(/\./g, '_');
}

function assertHeader(name, value) {
  if (!value) {
    throw new Error(`Bad .po file. "${name}" header is missing`);
  }
}

function writePoFile(poDatas, outpath, langName) {
  const dict = new Map();
  for (const poData of poDatas) {
    const pluralHeader =
      poData.headers['plural-forms'] || poData.headers['Plural-Forms'];
    const language = poData.headers.language || poData.headers.Language;
    assertHeader('Plural-Forms', pluralHeader);
    assertHeader('Language', language);
    for (const msg of Object.values(poData.translations[''])) {
      const msgid = msg.msgid;
      const msgstr = msg.msgstr;
      if (typeof msgid === 'string' && msgid.length &&
        Array.isArray(msgstr) && typeof msgstr[0] === 'string' && msgstr[0].length) {
        const src = msgid.replaceAll('"', '\\"');
        const dest = msgstr[0].replaceAll('"', '\\"');
        if (dest !== '') {
          dict.set(src, dest);
        }
      }
    }
  }
  const outstream = fs.createWriteStream(outpath, {flags: 'w'});
  outstream.write(`package locales

${autogenMsg}

`);
  const varName = langName.replaceAll('-', '_');
  outstream.write(`var dict_${varName} = map[string]string{\n`);
  const keys = Array.from(dict.keys()).sort((a, b) => a.localeCompare(b));
  const longestKeyLen = keys.reduce(
    (soFar, {length}) => length > soFar ? length : soFar,
    0,
  );
  for (const src of keys) {
    const dest = dict.get(src);
    if (src !== dest) {
      outstream.write(`\t"${src}": ${" ".repeat(longestKeyLen-src.length)}"${dest}",\n`);
    }
  }
  outstream.write(`}\n`);
  outstream.write(`
func Lookup_${varName}(s string) (string, bool) {
\tv, ok := dict_${varName}[s]
\tif ok {
\t\treturn v, true
\t}
\treturn s, false
}
`);
  outstream.end();
}
